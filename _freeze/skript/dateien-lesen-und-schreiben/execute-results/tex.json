{
  "hash": "b2aed25c4d35905449f3919b6fec52c5",
  "result": {
    "engine": "jupyter",
    "markdown": "# Dateien lesen und schreiben\nMaya und Hans haben je sechs Mal einen Würfel geworfen und ihre Wurfergebnisse in einer .txt-Datei protokolliert. Wir wollen mit die Dateien mit Python auswerten, um zu bestimmen, wer von beiden in Summe die höchste Augenzahl erreicht hat.\n\n| Daten | Dateiname |\n|---|------|\n| Würfelergebnisse Maya | dice-maya.txt |\n| Würfelergebnisse Hans | dice-hans.txt|\n\n&nbsp;\n\n## Dateiobjekte\nUm mit Python auf eine Datei zuzugreifen, muss diese fürs Lesen oder Schreiben geöffnet werden. Dazu wird in Python die Funktion [open](https://docs.python.org/3/library/functions.html#open) verwendet. Diese nimmt zwei Argumente, den Pfad der Datei und den Zugriffsmodus, an und liefert ein [Dateiobjekt](https://docs.python.org/3/glossary.html#term-file-object) zurück. Aus dem Dateiobjekt werden dann die Inhalte der Datei ausgelesen.\n\n### Dateipfad\nDer lokale Dateipfad wird ausgehend vom aktuellen Arbeitsverzeichnis angegeben.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\npfad_maya = \"01-daten/dice-maya.txt\"\npfad_hans = \"01-daten/dice-hans.txt\"\n```\n:::\n\n\n:::: {#tip-wd-Python .callout-tip collapse=\"true\"}\n## Arbeitsverzeichnis in Python ermitteln und wechseln\nDer Pfad des aktuellen Arbeitsverzeichnisses kann mit dem Modul os mittels `os.getcwd()` ermittelt werden (hier ohne Ausgabe). Mit `os.chdir('neuer_pfad')` kann das Arbeitsverzeichnis ggf. gewechselt werden. Die korrekte Formatierung des Pfads erkennen Sie an der Ausgabe von `os.getcwd()`.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport os\nprint(os.getcwd())\n```\n:::\n\n\nDas Importieren von Modulen wird in einem späteren Kapitel behandelt.\n::::\n\n### Zugriffsmodus\nAls Zugriffsmodus stehen unter anderem folgende Optionen zur Verfügung:\n\n| Modus | Beschreibung |\n| --- | ----------- |\n| `r` | lesender Zugriff |\n| `w` | Schreibzugriff, Datei wird überschrieben |\n| `x` | Erzeugt die Datei, Fehlermeldung, wenn die Datei bereits existiert |\n| `a` | Schreibzugriff, Inhalte werden angehängt |\n| `b` | Binärmodus (z. B. für Grafiken) |\n| `t` | Textmodus, default|\n\n&nbsp;\n\nDie Zugriffsmodi können auch kombiniert werden. Weitere Informationen dazu finden Sie in der [Dokumentation](https://docs.python.org/3/library/functions.html#open). Sofern nicht im Binärmodus auf Dateien zugegriffen wird, liefert die Funktion `open()` den Dateiinhalt als string zurück. \n\nIm Lesemodus wird ein Datenobjekt erzeugt. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndaten_maya = open(pfad_maya, mode = 'r')\nprint(daten_maya)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<_io.TextIOWrapper name='01-daten/dice-maya.txt' mode='r' encoding='UTF-8'>\n```\n:::\n:::\n\n\nWenn das Datenobjekt `daten_maya` der Funktion `print()` übergeben wird, gibt Python die Klasse des Objekts zurück, in diesem Fall also _io.TextIOWrapper. Diese Klasse stammt aus dem Modul io und ist für das Lesen und Schreiben von Textdateien zuständig. Ebenfalls werden als Attribute des Dateiobjekts der Dateipfad, der Zugriffsmodus und die Enkodierung der Datei ausgegeben (siehe @nte-attribute). Sollte die Enkodierung nicht automatisch als UTF-8 erkannt werden, kann diese mit dem Argument `encoding = 'UTF-8'` übergeben werden. \n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndaten_maya = open(pfad_maya, mode = 'r', encoding = 'UTF-8')\nprint(daten_maya)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<_io.TextIOWrapper name='01-daten/dice-maya.txt' mode='r' encoding='UTF-8'>\n```\n:::\n:::\n\n\n::: {#nte-attribute .callout-note collapse=\"true\"}\n## Attribute eines Objekts bestimmen\n\n Mit der Funktion `dir(objekt)` können die verfügbaren Attribute eines Objekts ausgegeben werden. Dabei werden jedoch auch die vererbten Attribute und Methoden der Klasse des Objekts ausgegeben, sodass die Ausgabe oft sehr umfangreich ist. Zum Beispiel für die Ganzzahl 1:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nprint(dir(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']\n```\n:::\n:::\n\n\nUm die Ausgabe auf Attribute einzugrenzen, kann folgende Funktion verwendet werden:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if not callable (getattr(objekt, attr))]\nprint(attribute)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['__doc__', 'denominator', 'imag', 'numerator', 'real']\n```\n:::\n:::\n\n\nMit doppelten Unterstrichen umschlossene Attribute sind für Python reserviert und nicht für den:die Nutzer:in gedacht. Folgende Funktion entfernt Attribute mit doppelten Unterstrichen aus der Ausgabe:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('__'))]\nprint(attribute)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['denominator', 'imag', 'numerator', 'real']\n```\n:::\n:::\n\n\nIm Fall einer Ganzzahl können Attribute (zur Abgrenzung von Gleitkommazahlen in umschließenden Klammern) wie folgt aufgerufen werden:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n(1).numerator\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n1\n```\n:::\n:::\n\n\nWenn wir uns die Attribute des Dateiobjekts 'daten_maya' ansehen, fallen Attribute mit einem einzelnen führenden Unterstrich auf.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nobjekt = daten_maya\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('__'))]\nprint(attribute)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['_CHUNK_SIZE', '_finalizing', 'buffer', 'closed', 'encoding', 'errors', 'line_buffering', 'mode', 'name', 'newlines', 'write_through']\n```\n:::\n:::\n\n\nHierbei handelt es sich um Attribute, die nicht durch den:die Nutzer:in aufgerufen werden sollen (weitere Informationen dazu finden Sie [hier](https://dbader.org/blog/meaning-of-underscores-in-python)). Folgender Programmcode gibt alle Attribute ohne führende Unterstriche aus:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nobjekt = daten_maya\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('_'))]\nprint(attribute)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['buffer', 'closed', 'encoding', 'errors', 'line_buffering', 'mode', 'name', 'newlines', 'write_through']\n```\n:::\n:::\n\n\n:::\n\nDie Attribute der Datei können mit entsprechenden Befehlen abgerufen werden.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nprint(f\"Dateipfad: {daten_maya.name}\\n\"\n      f\"Dateiname: {os.path.basename(daten_maya.name)}\\n\"\n      f\"Datei ist geschlossen: {daten_maya.closed}\\n\"\n      f\"Zugriffsmodus: {daten_maya.mode}\"\n      f\"Enkodierung: : {daten_maya.encoding}\")\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDateipfad: 01-daten/dice-maya.txt\nDateiname: dice-maya.txt\nDatei ist geschlossen: False\nZugriffsmodus: rEnkodierung: : UTF-8\n```\n:::\n:::\n\n\n::: {#tip-rückfalloption .callout-tip collapse=\"false\"}\n## Rückfalloption\n\nIn der Datenanalyse werden in der Regel spezialisierte Pakete wie NumPy oder Pandas verwendet. Diese vereinfachen das Einlesen von Dateien gegenüber der Pythonbasis erheblich. Dennoch ist es sinnvoll, sich mit den Methoden der Pythonbasis zum Einlesen von Dateien vertraut zu machen. Denn das Einlesen mit der Funktion `open()` klappt so gut wie immer - es ist eine gute Rückfalloption.\n:::\n\n### Dateiinhalt ausgeben {#sec-dateiinhalt}\nUm den Dateiinhalt auszugeben, kann das Datenobjekt mit einer Schleife zeilenweise durchlaufen und ausgegeben werden. (Die Datei dice-maya hat nur eine Zeile.) \n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ni = 0\nfor zeile in daten_maya:\n    print(f\"Inhalt Zeile {i}, mit {len(zeile)} Zeichen:\")\n    print(zeile)\n    i += 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInhalt Zeile 0, mit 28 Zeichen:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n```\n:::\n:::\n\n\nDies ist jedoch für größere Dateien nicht sonderlich praktikabel. Die Ausgabe einzelner Zeilen mit der Funktion `print()` kann aber nützlich sein, um die genaue Formatierung der Zeichenkette zu prüfen. In diesem Fall hat Maya ihre Daten in Anführungszeichen gesetzt und mit einem Komma voneinander getrennt.\n\n## Dateien einlesen\nUm den gesamten Inhalt einer Datei einzulesen, kann die Methode [datenobjekt.read()](https://docs.python.org/3/tutorial/inputoutput.html) verwendet werden. Die Methode hat als optionalen Parameter `.read(size)`. size wird als Ganzzahl übergeben und entsprechend viele Zeichen (im Binärmodus entsprechend viele Bytes) werden ggf. bis zum Dateiende ausgelesen. Der Parameter `size` ist nützlich, um die Formatierung des Inhalts einer großen Datei zu prüfen und dabei die Ausgabe auf eine überschaubare Anzahl von Zeichen zu begrenzen.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\naugen_maya = daten_maya.read()\n\nprint(f\"len(augen_maya): {len(augen_maya)}\\n\\n\"\n      f\"Inhalt der Datei augen_maya:\\n{augen_maya}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlen(augen_maya): 0\n\nInhalt der Datei augen_maya:\n\n```\n:::\n:::\n\n\nDas hat offensichtlich nicht geklappt, der ausgelesene Dateiinhalt ist leer! Der Grund dafür ist, dass beim Lesen (und beim Schreiben) einer Datei der Dateizeiger die Datei durchläuft. Nachdem die Datei daten_maya in @sec-dateiinhalt zeilenweise ausgegeben wurde, steht der Dateizeiger am Ende der Datei.\n\n:::: {#wrn-Dateizeiger .callout-warning appearance=\"simple\"}\n## Dateizeiger in Python\n\nWird eine Datei zeilenweise oder mit der Methode `.read()` ausgelesen, wird der Dateizeiger um die angegebene Zeichenzahl bzw. bis ans Ende der Datei bewegt. Wird beispielsweise ein Datensatz 'daten' geöffnet und mit der Methode `daten.read(3)` die ersten drei Zeichen ausgelesen, bewegt sich der Dateizeiger von der Indexposition 0 zur Indexposition 3 (bzw. steht jeweils davor).\n\n::::: {#fig-Dateizeiger layout-ncol=2}\n\n![](00-bilder/indexposition-0.png){fig-alt=\"Dargestellt ist ein in fünf Blöcke unterteilter Streifen, der einen eindimensionalen Datensatz repräsentiert. Die Blöcke sind entlang der 0. Achse von links nach rechts mit 0 bis 4 beschriftet. Oberhalb steht links vom Block Null ein Pfeil mit der Beschriftung Indexposition Null\"}\n\n![](00-bilder/indexposition-3.png){fig-alt=\"Dargestellt ist der gleiche Streifen. Oberhalb steht links vom Block drei ein Pfeil mit der Beschriftung Indexposition drei\"}\n\nBewegung des Dateizeigers beim Auslesen von drei Zeichen\n:::::\n\nDie Methode `daten.tell()` gibt zurück, an welcher Position sich der Dateizeiger befindet.\n\nMit der Methode `daten.seek(offset, whence = 0)` wird der Zeiger an eine bestimmte Position gesetzt. Die Methode akzeptiert das Argument offset (Versatz) und das optionale Argument whence (woher), dessen Standardwert 0 (Dateianfang) ist. Für Zugriffe **im Binärmodus** (`open(pfad, mode = 'rb')`) kann das Argument whence außerdem die Werte 1 (aktuelle Position) oder 2 (Dateiende) annehmen.\n\n  * `daten.seek(0, 0)` bezeichnet den Dateianfang\n\n  * `daten.seek(0, 1)` bezeichnet die aktuelle Position in der Datei\n\n  * `daten.seek(0, 2)` bezeichnet das Dateiende\n\n  * `daten.seek(-3, 2)` bezeichnet das dritte Zeichen vor dem Dateiende\n\n::::\n\nWird der Dateizeiger mit der Methode `datenobjekt.seek(0)` an den Dateianfang gestellt, gelingt das Auslesen der Datei.\n\n::: {.cell results='hold' execution_count=14}\n``` {.python .cell-code}\nprint(f\"Position des Dateizeigers vor dem Zurücksetzen auf 0: {daten_maya.tell()}\")\n\ndaten_maya.seek(0);\nprint(f\"Position des Dateizeigers nach dem Zurücksetzen auf 0: {daten_maya.tell()}\")\n\naugen_maya = daten_maya.read()\n\nprint(f\"Inhalt des Objekts augen_maya:\\n{augen_maya}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPosition des Dateizeigers vor dem Zurücksetzen auf 0: 28\nPosition des Dateizeigers nach dem Zurücksetzen auf 0: 0\nInhalt des Objekts augen_maya:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n```\n:::\n:::\n\n\n**Geben Sie aus dem Datenobjekt daten_maya mit den Methoden .seek() und .read() die Zahlen and zweiter und dritter Stelle, also 6 und 2, aus.**\n\n:::: {#tip-Musterlösung-Zeigerposition .callout-tip collapse=\"true\"}\n## Musterlösung Dateizeiger bewegen\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ndaten_maya.seek(6, 0);\nprint(daten_maya.read(1))\n\ndaten_maya.seek(daten_maya.tell() + 4, 0);\nprint(daten_maya.read(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n2\n```\n:::\n:::\n\n\n::::\n\nUm Mayas Würfelergebnisse zu addieren, müssen die Zahlen extrahiert und in Ganzzahlen umgewandelt werden, da im Textmodus stets eine Zeichenfolge zurückgegeben wird.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nprint(type(augen_maya))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'str'>\n```\n:::\n:::\n\n\nDazu werden mit der Methode `str.strip(\")` das führende und abschließende Anführungszeichen entfernt sowie anschließend mit der Methode `str.split('\", \"')` die Zeichenfolge über das Trennzeichen in eine Liste aufgeteilt. Anschließend werden die Listenelemente in Ganzzahlen umgewandelt und summiert. (Methoden der string-Bearbeitung werden im nächsten Abschnitt ausführlich behandelt.)\n\n::: {.cell results='hold' execution_count=17}\n``` {.python .cell-code}\nprint(f\"augen_maya:\\n{augen_maya}\")\n\naugen_maya = augen_maya.strip('\"')\nprint(f\"\\naugen_maya.strip('\\\"'):\\n{augen_maya}\")\n\naugen_maya = augen_maya.split('\", \"')\nprint(f\"\\naugen_maya.split('\\\", \\\"'):\\n{augen_maya}\")\n\naugen_maya_int = []\nfor i in augen_maya:\n  augen_maya_int.append(int(i))\n\nprint(f\"\\naugen_maya_int:\\n{augen_maya_int}\\n\\nSumme Augen: {sum(augen_maya_int)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\naugen_maya:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\naugen_maya.strip('\"'):\n5\", \"6\", \"2\", \"1\", \"4\", \"5\n\naugen_maya.split('\", \"'):\n['5', '6', '2', '1', '4', '5']\n\naugen_maya_int:\n[5, 6, 2, 1, 4, 5]\n\nSumme Augen: 23\n```\n:::\n:::\n\n\n#### Datei schließen\n\nNach dem Zugriff auf die Datei, muss diese wieder geschlossen werden, um diese für andere Programme freizugeben.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ndaten_maya.close()\n```\n:::\n\n\n:::: {#wrn-Schreiboperationen .callout-warning appearance=\"simple\"}\n# Schreiboperationen mit Python\n\nDas Schließen einer Datei ist besonders für Schreiboperationen auf Datenobjekten wichtig. Andernfalls kann es passieren, dass Inhalte mit `datenobjekt.write()` nicht vollständig auf den Datenträger geschrieben werden. Siehe dazu die [Dokumentation](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files).\n\n::::\n\n## Aufgabe Dateien einlesen\n\n**Welche Augenzahl hat Hans erreicht?**\n\n:::: {#tip-Musterlösung-Augenzahlvergleich .callout-tip collapse=\"true\"}\n## Musterlösung Augenzahlvergleich\n\n::::: {.border}\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# Erst Einlesen der Datei:\ndaten_hans = open(pfad_hans, mode = 'r', encoding = 'UTF-8')\naugen_hans = daten_hans.read()\nprint(augen_hans)\n# Hier muss man erkennen, dass Hans seinen Namen an den Anfang seiner Liste gesetzt hat. Dieser String muss also entfernt werden, bevor die Summe gebildet werden kann!\n\naugen_hans = augen_hans.strip('\"Hans\", ')\naugen_hans = augen_hans.strip('\"')\naugen_hans = augen_hans.split('\", \"')\nprint(augen_hans)\n# print-Ausgabe zeigt, dass die Liste nun korrekt bereinigt wurde. Sie besteht nur noch aus Integerwerten und diese können summiert werden\n\n# Neue (leere) Liste für die Würfe von Hans anlegen:\naugen_hans_int = []\nfor i in augen_hans:\n   augen_hans_int.append(int(i))\n\nprint(f\"Summe Augenzahl von Hans: {sum(augen_hans_int)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\"Hans\", \"3\", \"5\", \"1\", \"3\", \"2\", \"5\"\n['3', '5', '1', '3', '2', '5']\nSumme Augenzahl von Hans: 19\n```\n:::\n:::\n\n\nMusterlösung von Marc Sönnecken.\n:::::\n::::\n\n## Daten interpretieren\nDatensätze liegen typischerweise wenigstens in zweidimensionaler Form vor, d. h. die Daten sind in Zeilen und Spalten organisiert. Außerdem weisen Datensätze in der Regel auch unterschiedliche Datentypen auf. Die Funktion `open(datei)` gibt ein Dateiobjekt zurück, das mit Methoden wie zum Beispiel `dateiobjekt.read()` als Zeichenfolge eingelesen wird. Um die Daten sinnvoll weiterverarbeiten zu können, ist es deshalb notwendig, die Zeichenfolge korrekt zu interpretieren und Daten von Trennzeichen zu unterscheiden.\n\nFür die Bearbeitung von Zeichenfolgen bietet Python eine Reihe von [String-Methoden](https://docs.python.org/3/library/stdtypes.html#string-methods). Einige davon werden in diesem Kapitel exemplarisch verwendet. String-Methoden werden in der Regel mit einem führenden 'str' in der Form `str.methode()` genannt.\n\nBeispielsweise soll eine Datei mit den Einwohnerzahlen der europäischen Länder eingelesen werden. \n\n| Daten | Dateiname |\n|---|------|\n| Einwohner Europas | einwohner_europa_2019.csv |\n\n&nbsp;\n\nUm einen Überblick über den Aufbau der Datei zu erhalten, werden die ersten drei Zeilen der Datei ausgegeben. Dafür kann die Datei zeilenweise mit einer for-Schleife durchlaufen werden, die mit dem Schlüsselwort `break` abgebrochen wird, wenn die Laufvariable den Wert 3 erreicht hat. Eine andere Möglichkeit ist die Methode `dateiobjekt.readline()`, die eine einzelne Zeile ausliest. Hier wird die Häufigkeit der Schleifenausführung über die Laufvariable mit `for i in range(3):` gesteuert.\n\n::: {.panel-tabset}\n\n## for-Schleife mit break\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# erste 3 Zeilen anschauen\ni = 0\nfor zeile in dateiobjekt_einwohner:\n  \n  print(zeile)\n  i += 1\n  if i == 3:\n    break\n\n# Datei schließen\ndateiobjekt_einwohner.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGEO,Value\n\nBelgien,11467923\n\nBulgarien,7000039\n\n```\n:::\n:::\n\n\n## Methode dateiobjekt.readline()\n\nMit der Methode `dateiobjekt.readline()` kann eine einzelne Zeile eingelesen werden.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\nfor i in range(3):\n  print(dateiobjekt_einwohner.readline())\n\n# Datei schließen\ndateiobjekt_einwohner.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGEO,Value\n\nBelgien,11467923\n\nBulgarien,7000039\n\n```\n:::\n:::\n\n\n:::\n\nDie Datei hat also zwei Spalten. In der ersten Spalte sind die Ländernamen eingetragen, in der zweiten Spalte die Werte. Als Trennzeichen wird das Komma verwendet. In der ersten Zeile sind die Spaltenbeschriftungen eingetragen.\n\nIm vorherigen Abschnitt haben wir die Methode `dateiobjekt.read()` kennengelernt, mit der eine Datei vollständig als string eingelesen wird. \nZunächst wird die Datei mit der Methode `dateiobjekt.read()` in das Objekt einwohner eingelesen und wieder geschlossen.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\neinwohner = dateiobjekt_einwohner.read()\nprint(einwohner)\n\n# Datei schließen\ndateiobjekt_einwohner.close();\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGEO,Value\nBelgien,11467923\nBulgarien,7000039\nTschechien,10528984\nDaenemark,5799763\nDeutschland einschliesslich ehemalige DDR,82940663\nEstland,1324820\nIrland,4904240\nGriechenland,10722287\nSpanien,46934632\nFrankreich,67028048\nKroatien,4076246\nItalien,61068437\nZypern,875898\nLettland,1919968\nLitauen,2794184\nLuxemburg,612179\nUganda,-1\nUngarn,9772756\nMalta,493559\nNiederlande,17423013\nOesterreich,8842000\nPolen,37972812\nPortugal,10276617\nRumaenien,19405156\nSlowenien,2080908\nSlowakei,5450421\nFinnland,5512119\nSchweden,10243000\nVereinigtes Koenigreich,66647112\n\n```\n:::\n:::\n\n\nAnschließend können die eingelesenen Daten mit der Methode `str.split('\\n')` zeilweise aufgeteilt werden. Mit `'\\n'` wird als Argument der Zeilenumbruch übergeben. Die Methode liefert eine Liste zurück.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nliste_einwohner_zeilenweise = einwohner.split(\"\\n\")\nprint(liste_einwohner_zeilenweise[0:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['GEO,Value', 'Belgien,11467923', 'Bulgarien,7000039']\n```\n:::\n:::\n\n\nDie Liste enthält an der Indexposition die Spaltenbeschriftungen. Diese können mit der Methode `liste.pop(index)` aus der Liste entfernt und zugleich in einem neuen Objekt gespeichert werden.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nspaltennamen = liste_einwohner_zeilenweise.pop(0)\nspaltennamen = spaltennamen.split(',')\nprint(f\"Überschrift Spalte 0: {spaltennamen[0]}\\tÜberschrift Spalte 1: {spaltennamen[1]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nÜberschrift Spalte 0: GEO\tÜberschrift Spalte 1: Value\n```\n:::\n:::\n\n\nAnschließend kann die Liste mit der Methode `str.split(',')` nach Ländern und Werten aufgeteilt werden. Der Vorgang bricht allerdings mit einer Fehlermeldung ab. Die Fehlermeldung wird im folgenden Code-Block per Ausnahmebehandlung abgefangen. Neben der Fehlermeldung werden der verursachende Listeneintrag und dessen Indexposition ausgegeben.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\n\ntry:\n  for zeile in liste_einwohner_zeilenweise:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n\n  print(spaltennamen[0])\n  print(geo, \"\\n\")\n\n  print(spaltennamen[1])\n  print(einwohnerzahl)\n\nexcept Exception as error:\n  # print Fehlermeldung\n  print(f\"Fehlermeldung: {error}\")\n  \n  # print Eintrag und Index\n  print(f\"Eintrag: {eintrag}\\t Zeilenindex: {liste_einwohner_zeilenweise.index(zeile)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFehlermeldung: list index out of range\nEintrag: ['']\t Zeilenindex: 29\n```\n:::\n:::\n\n\nDie Fehlermeldung ist so zu deuten, dass eine der Listenoperationen mit dem Slice Operator einen ungültigen Index anspricht. Leicht angepasst, liefert der Code-Block auch die Ursache der Fehlermeldung. \n\nWird die leere Zeile aus der Liste entfernt, klappt das Aufteilen der Ländernamen und der Werte.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# leere Zeile entfernen\nliste_einwohner_zeilenweise.remove('')\n\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\n\ntry:\n  for zeile in liste_einwohner_zeilenweise:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n\n  print(spaltennamen[0])\n  print(geo, \"\\n\")\n\n  print(spaltennamen[1])\n  print(einwohnerzahl)\n\nexcept IndexError as error:\n  print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGEO\n['Belgien', 'Bulgarien', 'Tschechien', 'Daenemark', 'Deutschland einschliesslich ehemalige DDR', 'Estland', 'Irland', 'Griechenland', 'Spanien', 'Frankreich', 'Kroatien', 'Italien', 'Zypern', 'Lettland', 'Litauen', 'Luxemburg', 'Uganda', 'Ungarn', 'Malta', 'Niederlande', 'Oesterreich', 'Polen', 'Portugal', 'Rumaenien', 'Slowenien', 'Slowakei', 'Finnland', 'Schweden', 'Vereinigtes Koenigreich'] \n\nValue\n['11467923', '7000039', '10528984', '5799763', '82940663', '1324820', '4904240', '10722287', '46934632', '67028048', '4076246', '61068437', '875898', '1919968', '2794184', '612179', '-1', '9772756', '493559', '17423013', '8842000', '37972812', '10276617', '19405156', '2080908', '5450421', '5512119', '10243000', '66647112']\n```\n:::\n:::\n\n\n## Aufgabe Daten interpretieren\n1. Bestimmen Sie das Minimum und das Maximum der Einwohnerzahl und die dazugehörigen Länder.\n\n2. Bereinigen Sie ggf. fehlerhafte Werte. \n\n3. Wie viele Einwohner leben in Europa insgesamt?\n\n  - Welchen Datentyp hat die Liste einwohnerzahl?\n  \n  - Welchen Datentyp haben die Einträge der Liste einwohnerzahl?\n\n**Die Musterlösung kann Marc machen**\n\n::: {.callout-tip collapse=\"true\"}\n## Musterlösung vollständiges Einlesen\n\n:::\n\n## Einlesen als Liste\nEin Dateiobjekt kann auch direkt als Liste eingelesen werden. Die Methode `dateiobjekt.readlines()` gibt eine Liste zurück, in der jede Zeile einen Eintrag darstellt. Ebenso kann die Listenfunktion `list()` auf Dateiobjekte angewendet werden. Beide Vorgehensweisen liefern die gleiche Liste zurück, in der der Zeilenumbruch `\\n`  mit ausgelesen wird.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# Methode readlines\neinwohner = dateiobjekt_einwohner.readlines()\nprint(einwohner)\n\n## Dateizeiger zurücksetzen\ndateiobjekt_einwohner.seek(0);\n\n# Funktion list\neinwohner = list(dateiobjekt_einwohner)\nprint(einwohner)\n\n# Datei schließen\ndateiobjekt_einwohner.close();\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n```\n:::\n:::\n\n\nUm den Zeilenumbruch zu entfernen, könnte mit dem Slice Operator das letzte Zeichen jedes Listeneintrags entfernt werden.\n\nEine andere Möglichkeit ist die Methode `str.replace(old, new, count=-1)`, mit der Zeichen ersetzt oder gelöscht werden können. Die Parameter `old` und `new` geben die zu ersetzende bzw. die einzusetzende Zeichenfolge an und *müssen positional* übergeben werden. Über den Parameter `count` kann eingestellt werden, wie oft die Zeichenfolge `old` ersetzt werden soll. Standardmäßig wird jedes Vorkommen ersetzt.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nprint('Hund'.replace('Hu', 'Mu'))\n\nzeichenfolge = 'Ein  kurzer Text ohne  doppelte Leerzeichen.'\n\nprint(zeichenfolge.replace('  ', ' '))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMund\nEin kurzer Text ohne doppelte Leerzeichen.\n```\n:::\n:::\n\n\nDie Methode `str.replace()` kann auch zum Löschen verwendet werden. Wird für den Parameter `new` eine leere Zeichenfolge übergeben, wird die in `old` übergebene Zeichenfolge gelöscht.\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nprint(zeichenfolge.replace(' ', '').replace('doppelte', ''))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEinkurzerTextohneLeerzeichen.\n```\n:::\n:::\n\n\nMit der Methode `str.replace()` kann die eingelesene Liste um den Zeilenumbruch bereinigt werden.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# Methode readlines\neinwohner = dateiobjekt_einwohner.readlines()\neinwohner_neu = []\n\nfor element in einwohner:\n  einwohner_neu.append(element.replace('\\n', ''))\n\neinwohner = einwohner_neu\nprint(einwohner)\n\n# Datei schließen\ndateiobjekt_einwohner.close();\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['GEO,Value', 'Belgien,11467923', 'Bulgarien,7000039', 'Tschechien,10528984', 'Daenemark,5799763', 'Deutschland einschliesslich ehemalige DDR,82940663', 'Estland,1324820', 'Irland,4904240', 'Griechenland,10722287', 'Spanien,46934632', 'Frankreich,67028048', 'Kroatien,4076246', 'Italien,61068437', 'Zypern,875898', 'Lettland,1919968', 'Litauen,2794184', 'Luxemburg,612179', 'Uganda,-1', 'Ungarn,9772756', 'Malta,493559', 'Niederlande,17423013', 'Oesterreich,8842000', 'Polen,37972812', 'Portugal,10276617', 'Rumaenien,19405156', 'Slowenien,2080908', 'Slowakei,5450421', 'Finnland,5512119', 'Schweden,10243000', 'Vereinigtes Koenigreich,66647112']\n```\n:::\n:::\n\n\n## Dateien schreiben\nUm Dateien zu schreiben, müssen diese mit der `write`-Methode eines Dateiobjekts verwendet werden. Dieser Methode wird als Argument die zu schreibende Zeichenfolge übergeben.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\ndateipfad = \"01-daten/neue_datei.txt\"\n\n# Öffne Datei zum Schreiben öffnen\ndatei = open(dateipfad, mode = 'w')\n\n# Inhalt in die Datei schreiben\ndatei.write(\"Prokrastination an Hochschulen\\n\\n\".upper())\ndatei.write(\"KAPITEL 1: Aller Anfang ist schwer\\nPlatzhalter: Den Rest schreibe ich später.\")\n\n# Datei schließen\n\ndatei.close()\n```\n:::\n\n\nDie Datei kann nun ausgelesen werden.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\ndateiinhalt = open(dateipfad, mode = 'r')\ntext = dateiinhalt.read()\nprint(text)\n\ndateiinhalt.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPROKRASTINATION AN HOCHSCHULEN\n\nKAPITEL 1: Aller Anfang ist schwer\nPlatzhalter: Den Rest schreibe ich später.\n```\n:::\n:::\n\n\n## Aufgabe Dateien schreiben\n1.  Erzeugen Sie eine neue Datei mit der Endung `.txt`, die den Namen ihrer Heimatstadt hat. Schreiben Sie in diese Datei 10 Zeilen mit Informationen zur Stadt.\n\n&nbsp;\n(@Arnold-2023-funktionen-module-dateien)\n\n",
    "supporting": [
      "dateien-lesen-und-schreiben_files/figure-pdf"
    ],
    "filters": []
  }
}