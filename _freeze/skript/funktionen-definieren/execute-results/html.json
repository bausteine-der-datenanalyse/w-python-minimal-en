{
  "hash": "387e655702b358a4cf53b89ce195c0be",
  "result": {
    "engine": "jupyter",
    "markdown": "# Eigene Funktionen definieren\nDas Definieren eigener Funktionen eröffnet vielfältige Möglichkeiten in Python:\n\n  - Komplexe Programme können mit einer einzigen Zeile Code aufgerufen und ausgeführt werden.\n\n  - Funktionen können praktisch beliebig oft aufgerufen werden und sind durch den Einsatz von Parametern und Methoden der Flusskontrolle gleichzeitig in der Lage, flexibel auf wechselnde Bedingungen zu reagieren.\n\n  - Funktionen machen Programmcode kürzer und lesbarer. Außerdem gibt es nur eine Stelle, welche bei Änderungen angepasst werden muss.\n\n## Syntax\nDas Schlüsselwort `def` leitet die Funktionsdefinition ein. Es wird gefolgt vom Funktionsnamen und den Funktionsparametern, welche in runden Klammern `()` eingeschlossen sind. Der Funktionskopf wird mit einem Doppelpunkt `:` beendet. Der Anweisungsblock der Funktion ist eingerückt. Jede Funktion liefert einen Rückgabewert, welche durch das Schlüsselwort `return` an die aufrufende Stelle zurückgegeben wird.  `return` beendet die Ausführung der Schleife, auch wenn es nicht am Ende des Anweisungsblocks steht.\n\n::: {#904680a9 .cell execution_count=1}\n``` {.python .cell-code}\ndef Funktionsname(Parameter1, Parameter2):\n    Anweisungsblock\n    return Rückgabewert\n```\n:::\n\n\nDamit die Funktion ausgeführt wird, muss der definierte Funktionsname aufgerufen werden. In der Funktion ist nach dem Schlüsselwort `return` eine weitere Anweisung enthalten, die nicht mehr ausgeführt wird.\n\n::: {#42ce4d5c .cell execution_count=2}\n``` {.python .cell-code}\n# Beispiel 1: Summe der Quadrate\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_quadrate(a, b):\n    print('Argument a:', a)\n    print('Argument b:', b)\n    print(18 * '=')\n    summe = a**2 + b**2\n    return summe\n    print(\"Anweisungen nach dem Schlüsselwort return werden nicht mehr ausgeführt.\")\n\nprint(sum_quadrate(6, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArgument a: 6\nArgument b: 7\n==================\n85\n```\n:::\n:::\n\n\nDer Rückgabewert kann in einer Variablen gespeichert werden.\n\n::: {#6f81f227 .cell execution_count=3}\n``` {.python .cell-code}\nergebnis = sum_quadrate(6, 7)\nprint(ergebnis)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArgument a: 6\nArgument b: 7\n==================\n85\n```\n:::\n:::\n\n\n## Optionale Parameter\nMit Hilfe von optionalen Parametern kann die Programmausführung gesteuert werden. Optionale Parameter müssen nach verpflichtend zu übergebenen Parametern definiert werden. In diesem Beispiel wird die print-Ausgabe der Funktion mit dem Parameter `ausgabe` gesteuert.\n\n::: {#bb3148f0 .cell execution_count=4}\n``` {.python .cell-code}\n# Beispiel 2: optionale Argumente\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_quadrate(a, b, ausgabe = False):\n    if ausgabe:\n      print('Wert Argument a:', a)\n      print('Wert Argument b:', b)\n      print(18 * '=')\n    summe = a**2 + b**2\n    return summe\n\nprint(sum_quadrate(42, 7), \"\\n\")\nprint(sum_quadrate(42, 7, ausgabe = True))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1813 \n\nWert Argument a: 42\nWert Argument b: 7\n==================\n1813\n```\n:::\n:::\n\n\nGibt es mehrere optionale Parameter, so erfolgt die Zuweisung von Argumenten positional oder über das Schlüsselwort.\n\n::: {#4c66de64 .cell execution_count=5}\n``` {.python .cell-code}\n# Beispiel 3: mehrere optionale Argumente\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_potenzen(a, b, p = 2, ausgabe = False):\n    if ausgabe:\n      print('Argument a:', a)\n      print('Argument b:', b)\n      print('Argument p:', p)\n      print(18 * '=')\n    summe = a**p + b**p\n    return summe\n\n# positionale Übergabe\nprint(sum_potenzen(42, 7, 3, True), \"\\n\")\n\n# Übergabe per Schlüsselwort\nprint(sum_potenzen(42, 7, ausgabe = True, p = 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArgument a: 42\nArgument b: 7\nArgument p: 3\n==================\n74431 \n\nArgument a: 42\nArgument b: 7\nArgument p: 4\n==================\n3114097\n```\n:::\n:::\n\n\n## Rückgabewert(e)\nFunktionen können in Python nur einen einzigen Rückgabewert haben. Trotzdem können mehrere Rückgabewerte mit einem Komma getrennt werden. Python gibt diese als Tupel zurück.\n\n::: {#7a5e7d3a .cell execution_count=6}\n``` {.python .cell-code}\n# Beispiel 4: mehrere Rückgabewerte\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_potenzen(a, b, p = 2, ausgabe = False):\n    if ausgabe:\n      print('Argument a:', a)\n      print('Argument b:', b)\n      print('Argument p:', p)\n      print(18 * '=')\n    summe = a**p + b**p\n    return a, b, summe\n\nergebnis = sum_potenzen(2, 7, ausgabe = False, p = 4)\nprint(ergebnis, type(ergebnis))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(2, 7, 2417) <class 'tuple'>\n```\n:::\n:::\n\n\nMit dem Slice Operator kann ein bestimmter Rückgabewert ausgewählt werden.\n\n::: {#4700ac7a .cell execution_count=7}\n``` {.python .cell-code}\nprint(ergebnis[2])\n\nsumme_potenzen = sum_potenzen(2, 7, ausgabe = False, p = 4)[2]\nprint(summe_potenzen, type(summe_potenzen))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2417\n2417 <class 'int'>\n```\n:::\n:::\n\n\n<!-- ggf. ergänzen\n## anonyme Funktionen Lambdas\n<https://docs.python.org/3/reference/expressions.html#lambda> -->\n\n## Aufgaben Funktionen definieren\n1. Palindrom  \nSchreiben Sie eine Funktion is_palindrome(), die prüft, ob es sich bei einer übergebenen Zeichenkette um ein Palindrom handelt.\n\n*Hinweis: Ein Palindrom ist eine Zeichenkette, die von vorne und von hinten gelesen gleich bleibt, wie beispielsweise ‘Anna’, ‘Otto’, ‘Lagerregal’. Palindrome müssen nicht aus Buchstaben bestehen, sie können sich auch aus Zahlen oder Buchstaben und Zahlen zusammensetzen wie beispielsweise ‘345g543’.*\n\n2. Fibonacci-Zahlenreihe\n\nEntwickeln Sie eine Funktion fibonacci(n), die die ersten n Zahlen der Fibonacci-Reihe generiert und als Liste zurückgibt. Die Fibonacci-Reihe beginnt mit 0 und 1, jede weitere Zahl ist die Summe der beiden vorhergehenden Zahlen.\n\n3. Verschlüsselung\n\nBei Geocachen werden oft verschlüsselte Botschaften als Rätsel verwendet. Oft wird folgende Logik zur Verschlüsselung angewendet:\n\n* A -> Z\n\n* B -> Y\n\n* C -> X\n\n* ...\n\nSchreiben Sie eine Funktion `verschluesseln(str)`, die einen String als Eingabewert bekommt und einen verschlüsselten String zurückgibt. Wie können Sie einen verschlüsselten String am einfachsten wieder entschlüsseln?\n\n4. Temperaturkonverter\n\nEntwickeln Sie eine Funktion `temperatur_umrechnen(wert, von_einheit, nach_einheit)`, die eine Temperatur von einer Einheit in eine andere umwandelt. Die Funktion soll folgende Parameter verwenden:\n\n  - wert: Der Temperaturwert, der umgewandelt werden soll.\n  \n  - von_einheit / nach_einheit: Die Einheit des Ausgangs- bzw. des Zielwerts als string. Mögliche Werte sind 'C' für Celsius, 'F' für Fahrenheit und 'K' für Kelvin.\n\nEs gelten die folgenden Umrechnungsformeln zwischen den Einheiten:\n\n  - Celsius nach Fahrenheit: F = C * 9/5 + 32\n  \n  - Fahrenheit nach Celsius: C = (F - 32) * 5/9\n  \n  - Celsius nach Kelvin: K = C + 273.15\n  \n  - Kelvin nach Celsius: C = K - 273.15\n  \n  - Fahrenheit nach Kelvin: K = (F - 32) * 5/9 + 273.15\n  \n  - Kelvin nach Fahrenheit: F = (K - 273.15) * 9/5 + 32\n\n**Die Musterlösung kann Marc machen**\n\n::: {.callout-tip collapse=\"true\"}\n## Musterlösung Aufgaben Funktionen definieren\n\n:::\n\n&nbsp;\n(@Arnold-2023-funktionen-module-dateien)\n\n",
    "supporting": [
      "funktionen-definieren_files"
    ],
    "filters": [],
    "includes": {}
  }
}