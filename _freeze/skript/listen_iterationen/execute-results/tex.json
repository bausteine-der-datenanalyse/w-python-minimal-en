{
  "hash": "2e6289d5b4c7a84dd08cff1837478ba8",
  "result": {
    "engine": "jupyter",
    "markdown": "# Mehrere Werte speichern\n\nBisher haben Sie einzelne Werte in Variablen gespeichert. Doch was, wenn Sie eine ganze Reihe von Zahlen, Namen oder Werten auf einmal speichern möchten?\n\nDafür gibt es in Python **Listen**. In diesem Kapitel lernen Sie außerdem, wie man mit `for`-Schleifen über Listen iteriert.\n\n## Was ist eine Liste?\n\nEine Liste ist eine geordnete Sammlung von Werten eines Datentyps.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nnamen = [\"Ali\", \"Bente\", \"Carlos\"]\nnoten = [1.7, 2.3, 1.3, 2.0]\n```\n:::\n\n\nAuf Elemente greifen Sie mit eckigen Klammern zu:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nprint(namen[0])  # erstes Element\nprint(noten[-1]) # letztes Element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAli\n2.0\n```\n:::\n:::\n\n\n## Teile aus Listen ausschneiden – Slicing\n\nMit dem sogenannten **Slicing** können Sie gezielt Ausschnitte aus einer Liste entnehmen. \nDabei geben Sie an, **wo der Ausschnitt beginnt und wo er endet** (der Endwert \nwird **nicht** mehr mitgenommen):\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nzahlen = [10, 20, 30, 40, 50, 60]\nprint(zahlen[1:4])  # Ausgabe: [20, 30, 40]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[20, 30, 40]\n```\n:::\n:::\n\n\n### Syntax: `liste[start:stop]`\n\n- **start**: Index, bei dem das Slicing beginnt (inklusive)\n- **stop**: Index, an dem es endet (exklusive)\n- Der Startwert kann auch weggelassen werden: `[:3]` → erstes bis drittes Element\n- Ebenso der Endwert: `[3:]` → ab dem vierten Element bis zum Ende\n- Ganze Kopie: `[:]`\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(zahlen[:3])   # [10, 20, 30]\nprint(zahlen[3:])   # [40, 50, 60]\nprint(zahlen[:])    # vollständige Kopie\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10, 20, 30]\n[40, 50, 60]\n[10, 20, 30, 40, 50, 60]\n```\n:::\n:::\n\n\n::: {.callout-note icon=\"false\" collapse=\"false\"}\nSie können auch mit negativen Indizes arbeiten (`-1` ist das letzte Element):\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nprint(zahlen[-3:])  # [40, 50, 60]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[40, 50, 60]\n```\n:::\n:::\n\n\n:::\n\n## Über Listen iterieren\n\nMit einer `for`-Schleife können Sie über jedes Element in einer Liste iterieren:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nnamen = [\"Ali\", \"Bente\", \"Carlos\"]\n\nfor name in namen:\n    print(\"Hallo\", name + \"!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHallo Ali!\nHallo Bente!\nHallo Carlos!\n```\n:::\n:::\n\n\n## Erweiterung: Bedingte Ausgaben\n\nSie können in der Schleife mit `if` filtern:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ntemperaturen = [14.2, 17.5, 19.0, 21.3, 18.4]\n\nfor t in temperaturen:\n    if t > 18:\n        print(t, \"ist ein warmer Tag\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n19.0 ist ein warmer Tag\n21.3 ist ein warmer Tag\n18.4 ist ein warmer Tag\n```\n:::\n:::\n\n\n## Durchschnitt berechnen\n\nPython stellt nützliche Funktionen bereit, z. B. `sum()` und `len()`:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nnoten = [1.7, 2.3, 1.3, 2.0]\n\ndurchschnitt = sum(noten) / len(noten)\nprint(\"Durchschnittsnote:\", round(durchschnitt, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDurchschnittsnote: 1.82\n```\n:::\n:::\n\n\n## Listen erweitern: `.append()`\n\nManchmal kennen Sie die Listenelemente nicht vorher – dann können Sie neue Werte **nachträglich hinzufügen**:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nnamen = []\n\nnamen.append(\"Ali\")\nnamen.append(\"Bente\")\n\nprint(namen)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Ali', 'Bente']\n```\n:::\n:::\n\n\n::: {.callout-note icon=\"false\" collapse=\"false\"}\nDie Methode `.append())` hängt einen neuen Wert an das Ende der Liste.\n:::\n\n## Verschachtelte Schleifen\n\nWenn Sie mit **mehrdimensionalen Daten** arbeiten – z. B. eine Tabelle mit mehreren Zeilen – können Sie Schleifen **ineinander verschachteln**:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nwochentage = [\"Mo\", \"Di\", \"Mi\"]\nstunden = [1, 2, 3]\n\nfor tag in wochentage:\n    for stunde in stunden:\n        print(f\"{tag}, Stunde {stunde}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMo, Stunde 1\nMo, Stunde 2\nMo, Stunde 3\nDi, Stunde 1\nDi, Stunde 2\nDi, Stunde 3\nMi, Stunde 1\nMi, Stunde 2\nMi, Stunde 3\n```\n:::\n:::\n\n\nDas ergibt:\n\n```\nMo, Stunde 1\nMo, Stunde 2\nMo, Stunde 3\nDi, Stunde 1\n...\n```\n\n## Listen sortieren\n\nMit `sorted()` können Sie Listen **alphabetisch oder numerisch sortieren**:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nnamen = [\"Zoe\", \"Anna\", \"Ben\"]\nsortiert = sorted(namen)\n\nprint(sortiert)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Anna', 'Ben', 'Zoe']\n```\n:::\n:::\n\n\n::: {.callout-important icon=\"false\" collapse=\"false\"}\nDie Original-Liste bleibt **unverändert**.  \nWenn Sie die Liste direkt verändern möchten, geht das mit:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nnamen.sort()\n```\n:::\n\n\n:::\n\n",
    "supporting": [
      "listen_iterationen_files/figure-pdf"
    ],
    "filters": []
  }
}