{
  "hash": "904142fd82c5365170ee0dcca01772c2",
  "result": {
    "engine": "jupyter",
    "markdown": "# Sammeltypen\nSammeltypen werden benutzt, um mehrere Werte in einer Variablen zu speichern und zu verarbeiten. In Python gibt es vier Sammeltypen, die jeweils eine eigene Klasse sind:\n\n  - [Listen](https://de.wikipedia.org/wiki/Liste_(Datenstruktur)) enthalten eine flexible Anzahl von Elementen beliebigen Typs.\n\n  - [Tupel](https://de.wikipedia.org/wiki/Tupel_%28Informatik%29) können wie Listen Elemente beliebigen Typs enthalten, sind aber unveränderlich.\n\n  - [Mengen](https://de.wikipedia.org/wiki/Menge_%28Datenstruktur%29) sind ungeordnete Sammlungen, die jedes Element nur einmal enthalten können.\n\n  - [assoziative Arrays](https://de.wikipedia.org/wiki/Zuordnungstabelle_%28Datenstruktur%29) oder Dictionaries sind Zuordnungstabellen, d. h. sie bestehen aus Schlüssel-Wert-Paaren. \n  \nIn diesem Kapitel werden die vier Sammeltypen zunächst kurz vorgestellt. Anschließend wird die Arbeitsweise insbesondere mit Listen erläutert.\n\n## Listen\nWie alle Typen in Python werden Listen durch Zuweisung erstellt. Bei der Definition einer Liste werden die Elemente durch eckige Klammern `[]` eingeklammert und mit Kommata `,` getrennt. Listen können mit dem `+`-Operator verkettet werden. `*` verkettet eine Liste n-mal.\n\n::: {#05ec0c31 .cell execution_count=1}\n``` {.python .cell-code}\ntext_variable = 'abc'\n\nliste1 = [1, 'xy', True, text_variable]\nprint(liste1)\n\n# Listen können auch Listen enthalten\nliste2 = [None, liste1]\nprint(liste2)\n\n# Listen können mit + und * verkettet werden\nprint(liste1 + liste2)\nprint(liste1 * 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 'xy', True, 'abc']\n[None, [1, 'xy', True, 'abc']]\n[1, 'xy', True, 'abc', None, [1, 'xy', True, 'abc']]\n[1, 'xy', True, 'abc', 1, 'xy', True, 'abc']\n```\n:::\n:::\n\n\nEine leere Liste kann durch Zuweisung von `[]` erstellt werden.\n\n::: {#e3e1ffe4 .cell execution_count=2}\n``` {.python .cell-code}\nleere_liste = []\nprint(leere_liste)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[]\n```\n:::\n:::\n\n\n### Slicing: der Zugriffsoperator []\nDer Zugriff auf einzelne oder mehrere Elemente einer Liste (und andere Sammeltypen) erfolgt über den Zugriffsoperator []. Ein Ausschnitt aus einem Objekt wird Slice genannt, der Operator heißt deshalb auch Slice Operator.\n\n#### Zugriff auf einzelne Elemente\nElemente werden über ihren Index, bei 0 beginnend, angesprochen.\n\n::: {#ee584b57 .cell execution_count=3}\n``` {.python .cell-code}\nprint(liste1)\nprint(liste1[0])\nprint(liste1[3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 'xy', True, 'abc']\n1\nabc\n```\n:::\n:::\n\n\nAuf verschachtelte Listen kann mit zwei aufeinanderfolgenden Zugriffsoperatoren zugegriffen werden. Die Liste `liste2` enthält an Indexposition 1 eine Liste mit 4 Elementen.\n\n::: {#e1b672e4 .cell execution_count=4}\n``` {.python .cell-code}\nprint(liste2)\nprint(liste2[1])\nprint(liste2[1][0], liste2[1][1], liste2[1][2], liste2[1][3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[None, [1, 'xy', True, 'abc']]\n[1, 'xy', True, 'abc']\n1 xy True abc\n```\n:::\n:::\n\n\nMit negativen Indizes können Elemente vom Ende aus angesprochen werden. So entspricht z. B. die -1 dem letzten Element.\n\n::: {#ab933463 .cell execution_count=5}\n``` {.python .cell-code}\nprint(liste1)\nprint(liste1[-1], liste1[-3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 'xy', True, 'abc']\nabc xy\n```\n:::\n:::\n\n\n#### Zugriff auf mehrere Elemente\nIndexbereiche können in der Form `[start:stop:step]` angesprochen werden. `start` ist das erste adressierte Element, `stop` *das erste nicht mehr adressierte Element* und `step` die Schrittweite.\n\n::: {.border}\n\n| Zugriffsoperator | Ausschnitt |\n|---|---|\n| liste[start:stop] | Elemente von start bis stop - 1 |\n| liste[:] | Alle Elemente der Liste |\n| liste[start:] | Elemente von start bis zum Ende der Liste |\n| liste[:stop] | Elemente vom Anfang der Liste bis stop - 1 |\n| liste[::3] | Auswahl jedes dritten Elements |\n\n&nbsp;\n\nNegative Werte für `start`, `stop` oder `step` bewirken eine Rückwärtsauswahl von Elementen.\n\n| Zugriffsoperator | Ausschnitt |\n|---|---|\n| liste[-1] | das letzte Element der Liste |\n| liste[-2:] | die letzten beiden Elemente der Liste |\n| liste[:-2] | alle bis auf die beiden letzten Elemente |\n| liste[::-1] | alle Elemente in umgekehrter Reihenfolge |\n| liste[1::-1] | die ersten beiden Elemente in umgekehrter Reihenfolge |\n| liste[:-3:-1] | die letzten beiden Elemente in umgekehrter Reihenfolge |\n| liste[-3::-1] | alle außer die letzten beiden Elemente in umgekehrter Reihenfolge |\n\n&nbsp;\n\n(Beispiele von Greg Hewgill unter der Lizenz [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/deed.de) verfügbar auf [stackoverflow](https://stackoverflow.com/a/509295). 2009)\n:::\n\n#### Zeichenfolgen\nAuch aus Zeichenfolgen können mit dem Slice Operator Ausschnitte ausgewählt werden.\n\n::: {#71d59b76 .cell execution_count=6}\n``` {.python .cell-code}\nprint('Ich bin ein string'[::2])\nprint('Hallo Welt'[0:6])\nprint('abc'[::-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIhbnensrn\nHallo \ncba\n```\n:::\n:::\n\n\n### Listenmethoden\nFür den Listentyp sind verschiedene Methoden definiert.\n\n#### Elemente bestimmen\n\n- `list.index(x, start, stop)` gibt die Indexposition des ersten Elements x aus. Die optionalen Argumente `start` und `stop` erlauben es, den Suchbereich einzuschränken.\n\n- `list.count(x)` gibt die Häufigkeit von x in der Liste aus.\n\n- `list.reverse()` kehrt die Reihenfolge der Listenelemente um (die Liste wird dadurch verändert!). \n\n- `list.sort(reverse = False)` sortiert die Liste, mit dem optionalen Argument reverse = True absteigend (die Liste wird dadurch verändert!). Die Datentypen innerhalb der Liste müssen sortierbar sein (d. h. alle Elemente sind numerisch oder Zeichen).\n\n::: {#5e671ef1 .cell execution_count=7}\n``` {.python .cell-code}\nprint(liste1)\n\nliste1.reverse()\nprint(liste1)\n\n# True wird als 1 gezählt\nprint(\"True wird als 1 gezählt:\", liste1.index(1), liste1.count(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 'xy', True, 'abc']\n['abc', True, 'xy', 1]\nTrue wird als 1 gezählt: 1 2\n```\n:::\n:::\n\n\n#### Elemente einfügen\n\n- `list.append(x)` hängt ein einzelnes Element an das Ende der Liste an.\n\n- `list.extend(sammeltyp)` hängt alle mit `sammeltyp` übergebenen Elemente an das Ende der Liste an. Der Sammeltyp kann eine Liste, ein Tupel, eine Menge oder ein Dictionary sein.\n\n- `list.insert(i, x)` fügt an der Position i Element x ein.\n\n::: {#f35bc47b .cell execution_count=8}\n``` {.python .cell-code}\nprint(liste1, \"\\n\")\n\nliste1.append('Hallo')\nliste1.extend(['Hallo', 'Welt!'])\nliste1.insert(2, '12345')\n\nprint(liste1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['abc', True, 'xy', 1] \n\n['abc', True, '12345', 'xy', 1, 'Hallo', 'Hallo', 'Welt!']\n```\n:::\n:::\n\n\n#### Elemente entfernen\n\n- `list.remove(x)` entfernt *das erste* Element x in der Liste und gibt einen ValueError zurück, wenn x nicht in der Liste enthalten ist.\n\n- `liste.pop(i)` entfernt das Element an der Indexposition i. Wird kein Index angegeben, wird das letzte Element entfernt. Die Methode `liste.pop(i)` gibt die entfernten Elemente zurück.\n\n- `liste.clear()` entfernt alle Elemente einer Liste.\n\n::: {#07d54c19 .cell execution_count=9}\n``` {.python .cell-code}\nliste1.remove('Hallo')\nprint(liste1)\n\nliste1.pop(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['abc', True, '12345', 'xy', 1, 'Hallo', 'Welt!']\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n'12345'\n```\n:::\n:::\n\n\n#### Listen und Listenelemente kopieren\nIn Python enthalten Listen Daten nicht direkt, sondern bestehen aus Zeigern auf die Speicherorte der enthaltenen Elemente. Wird eine Liste durch Zuweisung einer anderen Liste angelegt, dann werden nicht die Elemente der Liste kopiert, sondern beide Listen  greifen dann auf den selben Speicherort zu.\n\n::: {#3f0a7356 .cell execution_count=10}\n``` {.python .cell-code}\n# Kopieren durch Zuweisung\nliste1 = [1, 'xy', True, text_variable]\nprint(\"liste1:\", liste1, \"\\n\")\nliste2 = liste1\n\n## Ändern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"Auch liste1 hat sich durch die Zuweisung in liste2 verändert:\", liste1, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nliste1: [1, 'xy', True, 'abc'] \n\nAuch liste1 hat sich durch die Zuweisung in liste2 verändert: ['ABC', 'xy', True, 'abc'] \n\n```\n:::\n:::\n\n\nUm eine Liste zu kopieren und ein neues Objekt im Speicher anzulegen, kann die Methode `liste.copy()` verwendet werden. Auch durch die Verwendung des Zugriffsoperators `[:]` wird eine neue Liste im Speicher angelegt.\n\n::: {#5829549e .cell execution_count=11}\n``` {.python .cell-code}\n# Verwendung der Methode liste.copy()\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1.copy()\n\n## Ändern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unverändert:\", liste1, \"\\n\")\n\n# Verwendung des Slice Operators\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1[:]\n\n## Ändern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unverändert:\", liste1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nliste1 bleibt durch die Zuweisung in liste2 unverändert: [1, 'xy', True, 'abc'] \n\nliste1 bleibt durch die Zuweisung in liste2 unverändert: [1, 'xy', True, 'abc']\n```\n:::\n:::\n\n\nDie Kopie von Listenelementen ist in dieser Hinsicht unproblematisch.\n\n::: {#cbb119a6 .cell execution_count=12}\n``` {.python .cell-code}\n# Verwendung des Slice Operators\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1[0:2]\n\n# Ändern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unverändert:\", liste1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nliste1 bleibt durch die Zuweisung in liste2 unverändert: [1, 'xy', True, 'abc']\n```\n:::\n:::\n\n\nUm zu überprüfen, ob sich zwei Objekte den Speicherbereich teilen, kann die Objekt-ID mit der Funktion `id()` verglichen oder die Operatoren `is` bzw. `is not` verwendet werden, die die Funktion `id()` aufrufen.\n\n::: {#a7290a34 .cell execution_count=13}\n``` {.python .cell-code}\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1\n\nprint(\"ID liste1:\", id(liste1))\nprint(\"ID liste2:\", id(liste2))\nprint(\"ID liste1 gleich ID list2:\", liste1 is liste2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nID liste1: 4355438848\nID liste2: 4355438848\nID liste1 gleich ID list2: True\n```\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Identität vs. Wertgleichheit\n\nDer Operator `is` prüft die Identität zweier Objekte und unterscheidet sich dadurch vom logischen Operator `==`, der auf Wertgleichheit prüft. Da liste1 und liste2 die gleichen Elemente enthalten, liegen sowohl Identität und Wertgleichheit vor. Der Unterschied von Identität und Wertgleichheit kann anhand eines Werts verdeutlicht werden (Im Code-Beispiel wird eine Syntax-Warnung unterdrückt.).\n\n::: {#429a1e54 .cell execution_count=14}\n``` {.python .cell-code}\n# Wertgleichheit\nprint(1 == 1.0)\nprint(liste1 == liste2, \"\\n\")\n\n# Identität\nprint(1 is 1.0)\nprint(liste1 is liste2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue \n\nFalse\nTrue\n```\n:::\n:::\n\n\n:::\n\n### Aufgaben Listen\n\n1. Erstellen Sie eine Liste 'wochentage', die die sieben Tage der Woche enthält. Verwenden Sie den Slice-Operator, um eine neue Liste 'wochenende' mit den Tagen des Wochenendes zu erstellen. Entfernen Sie die Tage des Wochenendes aus der Liste 'wochentage'.\n\n2. 4-Tage-Woche: Verwenden Sie Listenmethoden, um den Freitag aus der Liste 'wochentage' zu entfernen und der Liste 'wochenende' vor dem Samstag hinzuzufügen.\n\n3. Bestimmen Sie in der Liste `zahlen = [34, 12, 0, 67, 23]` die Position des Werts 0. Entfernen Sie den Wert aus der Liste und geben Sie die Liste aufsteigend sortiert aus. \n\n4. Geben Sie nun mit Hilfe des Zugriffsoperators `[]` die Indexpositionen 1 und 3 der sortierten Liste 'zahlen' aus.\n\n**Musterlösung kann Marc machen.**\n\n::: {#tip-listen .callout-tip collapse=\"true\"}\n## Musterlösung\n\n:::\n\n## Tupel\nTupel sind Listen sehr ähnlich, jedoch sind Tupel unveränderbare Datenobjekte. Das heißt, die Elemente eines angelegten Tupels können weder geändert, noch entfernt werden. Auch können keine neuen Elemente zum Tupel hinzugefügt werden.\n\nTupel werdem mit runden Klammern `()` erzeugt, die Elemente werden mit einem Komma `,` getrennt. Ein Tupel mit einem Wert wird mit einem Komma in der Form `(wert, )` angelegt. Der Zugriff auf die Elemente eines Tupels ist mit dem Slice-Operator `[start:stop:step]` möglich. Tupel können mit den Operatoren `+` und `*` verkettet werden.\n\n::: {#fec97b05 .cell execution_count=15}\n``` {.python .cell-code}\ntupel1 = (2, 7.8, 'Feuer', True, text_variable)\ntupel2 = (1, )\n\nprint(tupel1)\nprint(tupel1[2:4])\nprint(tupel1[::2])\nprint(tupel1[-1])\nprint(tupel1[2:4] + tupel2)\nprint(3 * tupel2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(2, 7.8, 'Feuer', True, 'abc')\n('Feuer', True)\n(2, 'Feuer', 'abc')\nabc\n('Feuer', True, 1)\n(1, 1, 1)\n```\n:::\n:::\n\n\n### Tupel kopieren\nTupel verhalten sich beim Kopieren gegensätzlich zu Listen. Für Tupel ist die Methode `.copy()` nicht definiert. Dagegen bewirkt die Kopie mittels dem Zugriffsoperator `[:]` zwar, dass zwei Tupel auf den selben Speicherplatz zugreifen. Bei der Neuzuweisung eines Tupels legt Python, wie für jedes Objekt, ein neues Objekt im Speicher an.\n\n::: {#931424eb .cell execution_count=16}\n``` {.python .cell-code}\n# Kopieren durch Zuweisung\ntupel1 = (1, 2, 3)\ntupel2 = tupel1\n\n## Neuzuweisung der Werte von tupel1\ntupel1 = (4, 5, 6)\nprint(f\"Die in tupel2 gespeicherten Werte sind unverändert:\\n{tupel1} {tupel2}\\n\")\n\n# Kopieren mit Slice Operator\ntupel1 = (1, 2, 3)\ntupel2 = tupel1[:]\nprint(tupel2 is tupel1)\n\n## Neuzuweisung der Werte von tupel1\ntupel1 = (4, 5, 6)\nprint(tupel1, tupel2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDie in tupel2 gespeicherten Werte sind unverändert:\n(4, 5, 6) (1, 2, 3)\n\nTrue\n(4, 5, 6) (1, 2, 3)\n```\n:::\n:::\n\n\n## Mengen\nIn Python können Mengen mit der `set()` Funktion z. B. aus einer Liste oder aus einem Tupel erzeugt oder durch geschweiften Klammern `{}` erstellt werden (eine leere Menge kann nur mit `set()` erzeugt werden, da `{}` ein leeres Dictionary anlegt). Mengen sind ungeordnete Sammelung, dementsprechend haben die Elemente keine Reihenfolge.\n\n::: {#8351b03f .cell execution_count=17}\n``` {.python .cell-code}\nliste = [1, 1, 5, 3, 3, 4, 2, 'a', 123, 1000, ('tupel', 5)]\nprint(\"Das Objekt liste als Menge:\\n\", set(liste))\n\nmenge = {1, 2, 3, 4, 5, 1000, ('tupel', 5), 'a', 123}\nprint(\"Die Menge kann auch mit geschweiften Klammern erzeugt werden:\", menge)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDas Objekt liste als Menge:\n {1, 2, 3, 4, 5, ('tupel', 5), 1000, 'a', 123}\nDie Menge kann auch mit geschweiften Klammern erzeugt werden: {1, 2, 3, 4, 5, ('tupel', 5), 1000, 'a', 123}\n```\n:::\n:::\n\n\nMengen können beispielsweise für Vergleichsoperationen verwendet werden.\n\n::: {#324dfdc7 .cell execution_count=18}\n``` {.python .cell-code}\nmenge_a = set('Python')\nmenge_b = set('ist super')\n\n# einzigartige Zeichen in a\nprint(\"Menge a:\", menge_a)\n\n# Zeichen in a, aber nicht in b\nprint(\"Menge a - b:\", menge_a - menge_b)\n\n# Zeichen in a oder b\nprint(\"Menge a | b:\", menge_a | menge_b)\n\n# Zeichen in a und b\nprint(\"Menge a & b:\", menge_a & menge_b)\n\n# Zeichen in a oder b, aber nicht in beiden (XOR)\nprint(\"Menge a ^ b:\", menge_a ^ menge_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMenge a: {'y', 't', 'o', 'n', 'h', 'P'}\nMenge a - b: {'y', 'o', 'n', 'h', 'P'}\nMenge a | b: {'y', 's', 't', 'u', 'o', 'n', 'p', ' ', 'h', 'e', 'i', 'r', 'P'}\nMenge a & b: {'t'}\nMenge a ^ b: {'s', 'y', 'u', 'o', 'n', 'p', 'r', 'h', 'e', 'i', ' ', 'P'}\n```\n:::\n:::\n\n\n### Mengen kopieren\nMengen verhalten sich wie Tupel mit dem Unterschied, dass die Methode `.copy()` für Mengen definiert ist. Allerdings kann der Zugriffsoperator `[]` nicht auf Mengen angewendet werden.\n\n::: {#2b04be96 .cell execution_count=19}\n``` {.python .cell-code}\n# Kopieren durch Zuweisung\nset1 = {1, 2, 3}\nset2 = set1\nprint(set1 is set2)\n\n## Neuzuweisen von set1\nset1 = {4, 5, 6}\nprint(f\"Die in set2 gespeicherten Werte sind unverändert:\\n{set1} {set2}\")\n\n# Kopieren durch Methode .copy()\nset1 = {1, 2, 3}\nset2 = set1.copy()\nprint(set1 is set2)\n\n## Neuzuweisen von set1\nset1 = {4, 5, 6}\nprint(f\"Die in set2 gespeicherten Werte sind unverändert:\\n{set1} {set2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nDie in set2 gespeicherten Werte sind unverändert:\n{4, 5, 6} {1, 2, 3}\nFalse\nDie in set2 gespeicherten Werte sind unverändert:\n{4, 5, 6} {1, 2, 3}\n```\n:::\n:::\n\n\n## Dictionaries\nDictionaries bestehen aus Schlüssel-Wert-Paaren. Die Schlüssel können Zahlen oder Zeichenketten sein, jeder Schlüssel darf nur einmal vorkommen. Dictionaries werden mit geschweiften Klammern `{}` definiert. Die Schlüssel und deren zugehörigen Werte werden mit einem Doppelpunkt `:` getrennt. Der Zugriff auf die Werte erfolgt mit dem Zugriffsoperator `[]`, welcher den oder die Schlüssel beinhaltet. Ein Zugriff über die Indexposition der Schlüssel ist nicht möglich, da Zahlen als Schlüssel interpretiert werden.\n\n::: {#1a0a05ad .cell execution_count=20}\n``` {.python .cell-code}\ndictionary1 = {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}\nprint(dictionary1, \"\\n\")\n\nprint(\"Werte des Schlüssels 1:\", dictionary1[1])\nprint(\"Werte des Schlüssels 'b':\",  dictionary1['b'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} \n\nWerte des Schlüssels 1: abc\nWerte des Schlüssels 'b': [1, 2, 3]\n```\n:::\n:::\n\n\nAuf die Schlüssel eines Dictionaries kann über die Methode `dictionary.keys()`, auf die Werte mittels der Methode `dictionary.values()` zugegriffen werden. \n\n::: {#9c1d7e6c .cell execution_count=21}\n``` {.python .cell-code}\nprint(\"Schlüssel:\", dictionary1.keys(), \"\\n\")\nprint(\"Werte:\", dictionary1.values())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSchlüssel: dict_keys([1, 'b', 'c']) \n\nWerte: dict_values(['abc', [1, 2, 3], ('tupel', 5, 6)])\n```\n:::\n:::\n\n\n### Dictionaries kopieren\nDictionaries verhalten sich beim Kopieren wie Listen, das heißt beim Kopieren durch Zuweisung teilen sich Dictionaries den Speicherbereich.\n\n::: {#ea7cdd0d .cell execution_count=22}\n``` {.python .cell-code}\n# Kopieren durch Zuweisung\nprint(\"dictionary:\", dictionary1, \"\\n\")\ndictionary2 = dictionary1\n\n## Ändern eines Elements in dictionary2\ndictionary2[1] = 'ABC'\nprint(\"Auch dictionary1 hat sich durch die Zuweisung in dictionary2 verändert:\\n\",\n       dictionary1, \"\\n\")\n\n# Verwendung der Methode dictionary.copy()\ndictionary1 = {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}\ndictionary2 = dictionary1.copy()\n\n## Ändern eines Elements in dictionary2\ndictionary2[1] = 'ABC'\nprint(\"dictionary1 bleibt durch die Zuweisung in dictionary2 unverändert:\\n\",\n       dictionary1, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndictionary: {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} \n\nAuch dictionary1 hat sich durch die Zuweisung in dictionary2 verändert:\n {1: 'ABC', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} \n\ndictionary1 bleibt durch die Zuweisung in dictionary2 unverändert:\n {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} \n\n```\n:::\n:::\n\n\n## Übersicht Sammeltypen\n| Merkmal                                        | Listen | Tupel | Mengen | Dictionary |\n|------------------------------------------------|--------|-------|--------|------------|\n| Beschreibung                            | flexible Anzahl von Elementen beliebigen Typs | Elemente beliebigen Typs, unveränderlich | ungeordnete Sammlung, jedes Element nur einmal enthalten | Zuordnungstabelle aus Schlüssel-Wert-Paaren |\n| Speicherbereich bei Zuweisung geteilt          | ja     | ja (aber unveränderlich)  | ja (aber Zugriffsoperator nicht anwendbar)   | ja         |\n| Methode .copy() definiert                      | ja     | nein  | ja     | ja         |\n| Slice-Operator anwendbar                       | ja     | ja    | nein   | ja (nach Schlüssel) |\n\n&nbsp;\n\n## Löschen: das Schlüsselwort del\nUm Sammeltypen, Elemente oder Slices zu löschen kann das Schlüsselwort `del` verwendet werden.\n\n::: {#4d6970aa .cell execution_count=23}\n``` {.python .cell-code}\n# Löschen einer Liste\ndel liste1\n\n# Löschen eines Indexbereichs aus einer Liste\nprint(\"Liste vor dem Löschen:\", liste2)\ndel liste2[1:3]\nprint(\"Liste nach dem Löschen:\", liste2)\n\n# Löschen eines Schlüsselworts aus einem Dictionary\nprint(\"Dictionary vor dem Löschen\", dictionary1)\ndel dictionary1[1]\nprint(\"Dictionary nach dem Löschen\", dictionary1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nListe vor dem Löschen: [1, 'xy', True, 'abc']\nListe nach dem Löschen: [1, 'abc']\nDictionary vor dem Löschen {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}\nDictionary nach dem Löschen {'b': [1, 2, 3], 'c': ('tupel', 5, 6)}\n```\n:::\n:::\n\n\n## Funktionen\nDie Sammeltypen können ineinander umgewandelt werden.\n\n::: {#55fbc278 .cell execution_count=24}\n``` {.python .cell-code}\ndictionary = {1: 'Kater', 2: 'Fähre', 3: 'Ricke'}\nprint( (liste := list(dictionary)) )\nprint( (menge := set(liste)) )\nprint( (tupel := tuple(menge)) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\n{1, 2, 3}\n(1, 2, 3)\n```\n:::\n:::\n\n\nEinige praktische Funktionen lassen sich auch auf Sammeltypen anwenden:\n\n* `len()` gibt die Anzahl der Elemente in einem Sammeltyp zurück.\n* `min()`, `max()`, `sum()` gibt das Minimum, Maximum bzw. die Summe eines Sammeltyps zurück (bei Dictionaries wird die Anzahl der Schlüssel gezählt).\n\n## Operationen: Verwendung von Schleifen\nUm arithmetische und logische Operatoren auf die in einem Sammeltyp gespeicherten Elemente anzuwenden, wird eine for-Schleife verwendet. Im folgenden Beispiel wird eine Liste 'zahlen' durchlaufen, die darin gespeicherten Zahlen quadriert und das jeweilige Ergebnis an die Liste 'quadratzahlen' angehängt. Auch wird geprüft, ob die quadrierten Zahlen ganzzahlig durch 3 teilbar sind und das Prüfergebnis in einer Liste 'modulo_3' gespeichert.\n\n::: {#lst-quadratzahlen}\n\n::: {#c0346f14 .cell execution_count=25}\n``` {.python .cell-code}\nzahlen = list(range(1, 11))\n\nquadratzahlen = [] # die Liste muss vor der Schleife angelegt werden\nmodulo_3 = [] # leere Liste vor der Schleife anlegen\n\nfor zahl in zahlen:\n  quadratzahl = zahl ** 2\n  quadratzahlen.append(quadratzahl)\n  modulo_3.append(quadratzahl % 3 == 0)\n\nprint(quadratzahlen)\nprint(modulo_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n[False, False, True, False, False, True, False, False, True, False]\n```\n:::\n:::\n\n\n:::\n\n## Aufgaben Sammeltypen\n1. Modifizieren Sie den Programmcode in @lst-quadratzahlen so, dass nur die Quadratzahlen gespeichert werden, die ganzzahlig durch 3 teilbar sind.\n\n2. Umrechnung von Geschwindigkeiten\nErstellen Sie ein Skript, welches eine Umrechnungstabelle für Geschwindigkeiten erzeugt. Folgende Randbedingungen sollen beachtet werden:\n\n* Die Umrechnung soll von km/h in m/s erfolgen.\n\n* Der Start- und Endwert soll in km/h frei wählbar sein, wobei beide ganzzahlig sein sollen.\n\n* Die Anzahl der Umrechnungspunkte soll definiert werden können und die Zwischenschritte (in km/h) immer als ganze Zahlen ausgegeben werden.\n\n*Tipp: In Ihrem Skript können Sie die Funktion [input()](https://docs.python.org/3/library/functions.html#input) verwenden, um Werte per Eingabe zu erfassen.*\n\n3. Sortieren: Gegeben ist die Liste `meine_liste = list(range(9, 0, -1))`. Diese soll mittels for-Schleifen sortiert werden.    \n\n::: {#tip-musterlösungsammeltypen .callout-tip collapse=\"true\"}\n## Musterlösung Aufgaben Sammeltypen\n\n1. Ganzzahlig durch 3 teilbare Quadratzahlen\n\n::: {#4f790e61 .cell execution_count=26}\n``` {.python .cell-code}\nzahlen = list(range(1, 11))\n\nquadratzahlen = [] # die Liste muss vor der Schleife angelegt werden\nmodulo_3 = [] # leere Liste vor der Schleife anlegen\n\nfor zahl in zahlen:\n  quadratzahl = zahl ** 2\n  if quadratzahl % 3 == 0:\n    quadratzahlen.append(quadratzahl)\n\nprint(quadratzahlen)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[9, 36, 81]\n```\n:::\n:::\n\n\n2. Umrechnung von Geschwindigkeiten\n\n::: {#04640c11 .cell execution_count=27}\n``` {.python .cell-code}\n# Freie Eingabe\n## start = int(input(\"Startwert in Kilometer pro Stunde eingeben.\"))\n## ende = int(input(\"Endwert in Kilometer pro Stunde eingeben.\"))\n## ausgabeschritte =  int(input(\"Anzahl auszugebener Schritte ein geben.\"))\n\n# Fixe Werte für die Lösung\nstart = 5\nende = 107\nausgabeschritte = 8\n\n# Liste für km erstellen\nschrittweite = (ende - start) / (ausgabeschritte - 1)\nliste_km = []\nfor i in range(ausgabeschritte):\n    liste_km.append(round(start + i * schrittweite))\n\n# Umrechnung\n# meter = 1000 * kilometer\n# Sekunde = Stunde * 60 * 60\nliste_m = []\nfor wert in liste_km:\n    liste_m.append(round((wert * 1000) / (60 * 60), 2))\n\n# Ausgabe\nprint(f\"Schrittweite: {schrittweite:.2f}\")\nprint(\"Kilometer pro Stunde\")\nprint(liste_km)\nprint(\"Meter pro Sekunde\")\nprint(liste_m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSchrittweite: 14.57\nKilometer pro Stunde\n[5, 20, 34, 49, 63, 78, 92, 107]\nMeter pro Sekunde\n[1.39, 5.56, 9.44, 13.61, 17.5, 21.67, 25.56, 29.72]\n```\n:::\n:::\n\n\n3. Sortieren: Bubble Sort Algorithmus\n\n::: {#2b58a5e0 .cell execution_count=28}\n``` {.python .cell-code}\n# statische Liste, Textausgabe\nmeine_liste = list(range(9, 0, -1))\n\nif len(meine_liste) > 1: \n\n    print(\"Liste zu Beginn\\t\\t  :\", meine_liste)\n\n    # äußere Schleife\n    Schritt = 0\n    for i in range(len(meine_liste) - 1):\n\n    # innere Schleife\n        for j in range(len(meine_liste) - 1):\n            if meine_liste[j] > meine_liste[j + 1]:\n                meine_liste[j], meine_liste[j + 1] = meine_liste[j + 1], meine_liste[j]\n\n        Schritt += 1\n        print(\"Liste nach Schritt \", Schritt, \":\", meine_liste)\n\n    print(\"\\nListe sortiert:\", *meine_liste) # * unterdrückt die Kommas zwischen den Listenelementen\n\nelse:\n    print(\"Die Liste muss mindenstens zwei Elemente enthalten!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nListe zu Beginn\t\t  : [9, 8, 7, 6, 5, 4, 3, 2, 1]\nListe nach Schritt  1 : [8, 7, 6, 5, 4, 3, 2, 1, 9]\nListe nach Schritt  2 : [7, 6, 5, 4, 3, 2, 1, 8, 9]\nListe nach Schritt  3 : [6, 5, 4, 3, 2, 1, 7, 8, 9]\nListe nach Schritt  4 : [5, 4, 3, 2, 1, 6, 7, 8, 9]\nListe nach Schritt  5 : [4, 3, 2, 1, 5, 6, 7, 8, 9]\nListe nach Schritt  6 : [3, 2, 1, 4, 5, 6, 7, 8, 9]\nListe nach Schritt  7 : [2, 1, 3, 4, 5, 6, 7, 8, 9]\nListe nach Schritt  8 : [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nListe sortiert: 1 2 3 4 5 6 7 8 9\n```\n:::\n:::\n\n\n:::\n\n&nbsp;  \n(@Arnold-2023-schleifen-abzweigungen)\n\n",
    "supporting": [
      "sammeltypen_files"
    ],
    "filters": [],
    "includes": {}
  }
}